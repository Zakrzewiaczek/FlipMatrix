#include "flipmatrix.h"
#include <furi_hal_spi_config.h>
#include <furi_hal_resources.h>
#include <storage/storage.h>
#include <string.h>
/* generated by fbt from .png files in images folder */
#include <flipmatrix_icons.h>

// Get timer interval based on scroll speed setting
static uint32_t get_scroll_timer_interval(uint8_t scroll_speed) {
    switch(scroll_speed) {
    case 0: // Slow
        return 270;
    case 1: // Medium
        return 120;
    case 2: // Fast
        return 100;
    default:
        return 150; // Default to medium
    }
}

// Get timer interval based on flash speed setting
static uint32_t get_flash_timer_interval(uint8_t flash_speed) {
    switch(flash_speed) {
    case 0: // Slow
        return 700;
    case 1: // Medium
        return 400;
    case 2: // Fast
        return 150;
    default:
        return 400; // Default to medium
    }
}

// Timer callback for flashing text animation
static void flash_timer_callback(void* context) {
    App* app = context;
    
    if(!app->flash_active || !app->matrix_connected) return;
    
    const char* text = furi_string_get_cstr(app->flash_text);
    size_t text_len = strlen(text);
    
    if(text_len == 0) return;
    
    // Get current character to display
    if(app->flash_current_char < text_len) {
        char current_char[2] = {text[app->flash_current_char], '\0'};
        
        // Clear display and show current character in center
        max7219_clear_display(app->max7219);
        max7219_display_char(app->max7219, current_char[0], 1, 0); // Draw character
        
        // Move to next character
        app->flash_current_char++;
    } else {
        // Reset to beginning when we reach the end, but with longer pause
        app->flash_current_char = 0;
        
        // Restart timer with longer interval for pause between cycles
        furi_timer_stop(app->flash_timer);
        furi_timer_start(app->flash_timer, get_flash_timer_interval(app->scroll_speed) * 3); // 3x longer pause
        
        // Clear display during pause
        max7219_clear_display(app->max7219);
        return;
    }
    
    // Restart timer with normal interval
    furi_timer_stop(app->flash_timer);
    furi_timer_start(app->flash_timer, get_flash_timer_interval(app->scroll_speed));
}

// Timer callback for scrolling text animation
static void scroll_timer_callback(void* context) {
    App* app = context;
    
    if(!app->scroll_active || !app->matrix_connected) return;
    
    if(app->scroll_direction == 0) { // Horizontal scrolling
        // Display text horizontally with horizontal scrolling
        max7219_display_text_horizontal(app->max7219, furi_string_get_cstr(app->scroll_text), app->scroll_position, 0, 1);
        
        // Move scroll position left
        app->scroll_position--;
        
        // Calculate when to reset: text width + extra space to fully scroll off screen
        uint16_t text_width = max7219_get_text_width(furi_string_get_cstr(app->scroll_text), 1);
        int16_t reset_position = -(int16_t)text_width - 8; // Extra space to completely hide last character
        
        if(app->scroll_position < reset_position) {
            app->scroll_position = 8; // Reset to start position for horizontal
        }
    } else { // Vertical scrolling
        // Display text vertically with vertical scrolling
        max7219_display_text_vertical(app->max7219, furi_string_get_cstr(app->scroll_text), 2, app->scroll_position, 1);
        
        // Move scroll position down
        app->scroll_position--;
        
        // Calculate when to reset: text height + extra space to fully scroll off screen
        uint16_t text_height = max7219_get_text_height(furi_string_get_cstr(app->scroll_text), 1);
        int16_t reset_position = -(int16_t)text_height - 8; // Extra space to completely hide last character
        
        if(app->scroll_position < reset_position) {
            app->scroll_position = 8; // Reset to above display
        }
    }
}

void flipmatrix_menu_callback(void* context, uint32_t index) {
    App* app = context;
    switch(index) {
    case FlipMatrixMainMenuSceneConnect:
        scene_manager_handle_custom_event(app->scene_manager, FlipMatrixMainMenuSceneConnectEvent);
        break;
    case FlipMatrixMainMenuSceneHowToConnect:
        scene_manager_handle_custom_event(
            app->scene_manager, FlipMatrixMainMenuSceneHowToConnectEvent);
        break;
    case FlipMatrixMainMenuSceneAbout:
        scene_manager_handle_custom_event(app->scene_manager, FlipMatrixMainMenuSceneAboutEvent);
        break;
    }
}

void flipmatrix_connected_menu_callback(void* context, uint32_t index) {
    App* app = context;
    switch(index) {
    case FlipMatrixConnectedMenuSceneTextDisplay:
        scene_manager_handle_custom_event(app->scene_manager, FlipMatrixConnectedMenuSceneTextDisplayEvent);
        break;
    case FlipMatrixConnectedMenuSceneFlashingText:
        scene_manager_handle_custom_event(app->scene_manager, FlipMatrixConnectedMenuSceneFlashingTextEvent);
        break;
    case FlipMatrixConnectedMenuSceneImageDisplay:
        scene_manager_handle_custom_event(app->scene_manager, FlipMatrixConnectedMenuSceneImageDisplayEvent);
        break;
    case FlipMatrixConnectedMenuSceneSettings:
        scene_manager_handle_custom_event(app->scene_manager, FlipMatrixConnectedMenuSceneSettingsEvent);
        break;
    }
}

void flipmatrix_main_menu_scene_on_enter(void* context) {
    App* app = context;

    // If we return from the connected submenu, we deinitialize the display
    if(app->matrix_connected && app->max7219) {
        max7219_clear_display(app->max7219);
        max7219_deinit(app->max7219);
        app->matrix_connected = false;
    }

    submenu_reset(app->submenu);
    submenu_set_header(app->submenu, "FlipMatrix");
    submenu_add_item(
        app->submenu, "Connect", FlipMatrixMainMenuSceneConnect, flipmatrix_menu_callback, app);
    submenu_add_item(
        app->submenu,
        "How to connect",
        FlipMatrixMainMenuSceneHowToConnect,
        flipmatrix_menu_callback,
        app);
    submenu_add_item(
        app->submenu, "About", FlipMatrixMainMenuSceneAbout, flipmatrix_menu_callback, app);
    view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixSubmenuView);
}

bool flipmatrix_main_menu_scene_on_event(void* context, SceneManagerEvent event) {
    App* app = context;
    bool consumed = false;
    switch(event.type) {
    case SceneManagerEventTypeCustom:
        switch(event.event) {
        case FlipMatrixMainMenuSceneConnectEvent:
            scene_manager_next_scene(app->scene_manager, FlipMatrixConnectScene);
            consumed = true;
            break;
        case FlipMatrixMainMenuSceneHowToConnectEvent:
            scene_manager_next_scene(app->scene_manager, FlipMatrixHowToConnectScene);
            consumed = true;
            break;
        case FlipMatrixMainMenuSceneAboutEvent:
            scene_manager_next_scene(app->scene_manager, FlipMatrixAboutScene);
            consumed = true;
            break;
        }
        break;
    default:
        break;
    }
    return consumed;
}

void flipmatrix_main_menu_scene_on_exit(void* context) {
    App* app = context;
    submenu_reset(app->submenu);
}

void flipmatrix_connect_scene_on_enter(void* context) {
    App* app = context;
    widget_reset(app->widget);

    // Try to initialize MAX7219
    if(max7219_init(app->max7219)) {
        app->matrix_connected = true;

        widget_add_string_element(
            app->widget, 64, 15, AlignCenter, AlignCenter, FontPrimary, "MAX7219 Connected!");
        widget_add_string_element(
            app->widget, 64, 30, AlignCenter, AlignCenter, FontSecondary, "Connection successful");
        widget_add_string_element(
            app->widget, 64, 45, AlignCenter, AlignCenter, FontSecondary, "Going to menu...");
        
        // Show the widget first
        view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixWidgetView);

        // Test pattern to confirm connection
        for(int i = 0; i < 4; i++)
        {
            max7219_clear_display(app->max7219);
            if(i%2==0) // Blink 2 times
            {
                max7219_set_pixel(app->max7219, 0, 0, true); // Top-left
                max7219_set_pixel(app->max7219, 0, 7, true); // Top-right
                max7219_set_pixel(app->max7219, 7, 0, true); // Bottom-left
                max7219_set_pixel(app->max7219, 7, 7, true); // Bottom-right
                max7219_set_pixel(app->max7219, 3, 3, true); // Center
                max7219_set_pixel(app->max7219, 3, 4, true); // Center
                max7219_set_pixel(app->max7219, 4, 3, true); // Center
                max7219_set_pixel(app->max7219, 4, 4, true); // Center
            }

            furi_delay_ms(250);
        }

        scene_manager_next_scene(app->scene_manager, FlipMatrixConnectedMenuScene);
        return;
    } else {
        widget_add_string_element(
            app->widget, 64, 20, AlignCenter, AlignCenter, FontPrimary, "Connection Failed");
        widget_add_string_element(
            app->widget, 64, 35, AlignCenter, AlignCenter, FontSecondary, "Check wiring");
    }

    view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixWidgetView);
}

bool flipmatrix_connect_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false; // event not handled.
}

void flipmatrix_connect_scene_on_exit(void* context) {
    App* app = context;
    widget_reset(app->widget);
}

void flipmatrix_connected_menu_scene_on_enter(void* context) {
    App* app = context;
    submenu_reset(app->submenu);
    submenu_set_header(app->submenu, "FlipMatrix - Connected");
    submenu_add_item(
        app->submenu, "Scroll text", FlipMatrixConnectedMenuSceneTextDisplay, flipmatrix_connected_menu_callback, app);
    submenu_add_item(
        app->submenu, "Flashing text", FlipMatrixConnectedMenuSceneFlashingText, flipmatrix_connected_menu_callback, app);
    submenu_add_item(
        app->submenu, "Image", FlipMatrixConnectedMenuSceneImageDisplay, flipmatrix_connected_menu_callback, app);
    submenu_add_item(
        app->submenu, "Settings", FlipMatrixConnectedMenuSceneSettings, flipmatrix_connected_menu_callback, app);
    view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixSubmenuView);
}

bool flipmatrix_connected_menu_scene_on_event(void* context, SceneManagerEvent event) {
    App* app = context;
    bool consumed = false;
    switch(event.type) {
    case SceneManagerEventTypeCustom:
        switch(event.event) {
        case FlipMatrixConnectedMenuSceneTextDisplayEvent:
            scene_manager_next_scene(app->scene_manager, FlipMatrixTextInputScene);
            consumed = true;
            break;
        case FlipMatrixConnectedMenuSceneFlashingTextEvent:
            scene_manager_next_scene(app->scene_manager, FlipMatrixFlashingTextInputScene);
            consumed = true;
            break;
        case FlipMatrixConnectedMenuSceneImageDisplayEvent:
            scene_manager_next_scene(app->scene_manager, FlipMatrixImageDisplayScene);
            consumed = true;
            break;
        case FlipMatrixConnectedMenuSceneSettingsEvent:
            scene_manager_next_scene(app->scene_manager, FlipMatrixSettingsScene);
            consumed = true;
            break;
        }
        break;
    case SceneManagerEventTypeBack:
        // Go directly to main menu instead of connect scene
        scene_manager_search_and_switch_to_previous_scene(app->scene_manager, FlipMatrixMainMenuScene);
        consumed = true;
        break;
    default:
        break;
    }
    return consumed;
}

void flipmatrix_connected_menu_scene_on_exit(void* context) {
    App* app = context;
    submenu_reset(app->submenu);
}

// Text Input Scene callback
static void text_input_result_callback(void* context) {
    App* app = context;
    // User confirmed text input, now go to text display scene
    scene_manager_next_scene(app->scene_manager, FlipMatrixTextDisplayScene);
}

// Flashing Text Input Scene callback
static void flashing_text_input_result_callback(void* context) {
    App* app = context;
    // User confirmed text input, now go to flashing text display scene
    scene_manager_next_scene(app->scene_manager, FlipMatrixFlashingTextDisplayScene);
}

void flipmatrix_text_input_scene_on_enter(void* context) {
    App* app = context;
    
    text_input_reset(app->text_input);
    text_input_set_header_text(app->text_input, "Enter text to display:");
    text_input_set_result_callback(
        app->text_input,
        text_input_result_callback,
        app,
        app->text_input_buffer,
        FLIPMATRIX_TEXT_INPUT_MAX_LEN,
        true); // Clear default text when editing
    
    view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixTextInputView);
}

bool flipmatrix_text_input_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false; // event not handled
}

void flipmatrix_text_input_scene_on_exit(void* context) {
    App* app = context;
    text_input_reset(app->text_input);
}

void flipmatrix_text_display_scene_on_enter(void* context) {
    App* app = context;
    widget_reset(app->widget);

    if(!app->matrix_connected) {
        widget_add_string_element(
            app->widget, 64, 20, AlignCenter, AlignCenter, FontPrimary, "Not Connected");
        widget_add_string_element(
            app->widget, 64, 35, AlignCenter, AlignCenter, FontSecondary, "Connect first!");
    } else {
        // Setup scrolling text from user input
        furi_string_set_str(app->scroll_text, app->text_input_buffer);
        
        // Set scroll position based on direction
        if(app->scroll_direction == 0) { // Horizontal
            app->scroll_position = 8; // Start position for horizontal
        } else { // Vertical
            app->scroll_position = 8; // Start position for vertical
        }
        
        app->scroll_active = true;
        
        // Create and start timer for animation with user-defined speed
        app->scroll_timer = furi_timer_alloc(scroll_timer_callback, FuriTimerTypePeriodic, app);
        furi_timer_start(app->scroll_timer, get_scroll_timer_interval(app->scroll_speed));
        
        widget_add_string_element(
            app->widget, 64, 15, AlignCenter, AlignCenter, FontPrimary, "Text Display");
        widget_add_string_element(
            app->widget, 64, 30, AlignCenter, AlignCenter, FontSecondary, furi_string_get_cstr(app->scroll_text));
        widget_add_string_element(
            app->widget, 64, 45, AlignCenter, AlignCenter, FontSecondary, "Press Back to stop");
    }

    view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixWidgetView);
}

bool flipmatrix_text_display_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false; // event not handled.
}

void flipmatrix_text_display_scene_on_exit(void* context) {
    App* app = context;
    
    // Stop scrolling animation
    app->scroll_active = false;
    if(app->scroll_timer) {
        furi_timer_stop(app->scroll_timer);
        furi_timer_free(app->scroll_timer);
        app->scroll_timer = NULL;
    }
    
    // Clear display
    if(app->matrix_connected) {
        max7219_clear_display(app->max7219);
    }
    
    widget_reset(app->widget);
}

void flipmatrix_flashing_text_input_scene_on_enter(void* context) {
    App* app = context;
    
    text_input_reset(app->text_input);
    text_input_set_header_text(app->text_input, "Enter flashing text:");
    text_input_set_result_callback(
        app->text_input,
        flashing_text_input_result_callback,
        app,
        app->text_input_buffer,
        FLIPMATRIX_TEXT_INPUT_MAX_LEN,
        true);
    
    view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixTextInputView);
}

bool flipmatrix_flashing_text_input_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false; // event not handled.
}

void flipmatrix_flashing_text_input_scene_on_exit(void* context) {
    App* app = context;
    text_input_reset(app->text_input);
}

void flipmatrix_flashing_text_display_scene_on_enter(void* context) {
    App* app = context;
    widget_reset(app->widget);

    if(!app->matrix_connected) {
        widget_add_string_element(
            app->widget, 64, 20, AlignCenter, AlignCenter, FontPrimary, "Not Connected");
        widget_add_string_element(
            app->widget, 64, 35, AlignCenter, AlignCenter, FontSecondary, "Connect first!");
    } else {
        // Copy text from input buffer to flash_text
        furi_string_set(app->flash_text, app->text_input_buffer);
        
        // Setup flashing text animation
        app->flash_current_char = 0;
        app->flash_active = true;
        
        // Create and start timer for animation with user-defined speed
        app->flash_timer = furi_timer_alloc(flash_timer_callback, FuriTimerTypePeriodic, app);
        furi_timer_start(app->flash_timer, get_flash_timer_interval(app->scroll_speed));

        widget_add_string_element(
            app->widget, 64, 15, AlignCenter, AlignCenter, FontPrimary, "Flashing Text");
        widget_add_string_element(
            app->widget, 64, 30, AlignCenter, AlignCenter, FontSecondary, "Flashing characters");
        widget_add_string_element(
            app->widget, 64, 45, AlignCenter, AlignCenter, FontSecondary, "Press Back to stop");
    }

    view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixWidgetView);
}

bool flipmatrix_flashing_text_display_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false; // event not handled.
}

void flipmatrix_flashing_text_display_scene_on_exit(void* context) {
    App* app = context;
    
    // Stop flashing animation
    app->flash_active = false;
    if(app->flash_timer) {
        furi_timer_stop(app->flash_timer);
        furi_timer_free(app->flash_timer);
        app->flash_timer = NULL;
    }
    
    // Clear display
    if(app->matrix_connected) {
        max7219_clear_display(app->max7219);
    }
    
    widget_reset(app->widget);
}

void flipmatrix_image_display_scene_on_enter(void* context) {
    App* app = context;
    
    if(!app->matrix_connected) {
        widget_reset(app->widget);
        widget_add_string_element(
            app->widget, 64, 20, AlignCenter, AlignCenter, FontPrimary, "Not Connected");
        widget_add_string_element(
            app->widget, 64, 35, AlignCenter, AlignCenter, FontSecondary, "Connect first!");
        view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixWidgetView);
    } else {
        // Open file browser to select .fmtx file
        DialogsFileBrowserOptions browser_options;
        dialog_file_browser_set_basic_options(&browser_options, ".fmtx", &I_Apps_10px);
        browser_options.hide_ext = false;
        
        furi_string_set_str(app->file_path, STORAGE_EXT_PATH_PREFIX);
        
        if(dialog_file_browser_show(app->dialogs, app->file_path, app->file_path, &browser_options)) {
            // File selected, load and display it
            flipmatrix_load_and_display_fmtx_file(app);
        } else {
            // No file selected or cancelled, return to main menu
            scene_manager_previous_scene(app->scene_manager);
        }
    }
}

bool flipmatrix_image_display_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false; // event not handled.
}

void flipmatrix_image_display_scene_on_exit(void* context) {
    App* app = context;
    widget_reset(app->widget);
}

void flipmatrix_load_and_display_fmtx_file(void* context) {
    App* app = context;
    
    // Open and read the .fmtx file
    Storage* storage = furi_record_open(RECORD_STORAGE);
    File* file = storage_file_alloc(storage);
    
    if(storage_file_open(file, furi_string_get_cstr(app->file_path), FSAM_READ, FSOM_OPEN_EXISTING)) {
        uint8_t matrix_data[8] = {0};
        storage_file_read(file, matrix_data, 8);
        
        // Clear display and show the image
        max7219_clear_display(app->max7219);
        
        // Display the matrix data
        for(int row = 0; row < 8; row++) {
            for(int col = 0; col < 8; col++) {
                bool pixel_on = (matrix_data[row] >> (7 - col)) & 1;
                max7219_set_pixel(app->max7219, row, col, pixel_on);
            }
        }
        
        // Update widget to show file info
        widget_reset(app->widget);
        widget_add_string_element(
            app->widget, 64, 15, AlignCenter, AlignCenter, FontPrimary, "Image Display");
        
        // Show filename (extract from path)
        const char* filename = furi_string_get_cstr(app->file_path);
        const char* basename = strrchr(filename, '/');
        if(basename) basename++;
        else basename = filename;
        
        char filename_display[32];
        snprintf(filename_display, sizeof(filename_display), "File: %.20s", basename);
        widget_add_string_element(
            app->widget, 64, 30, AlignCenter, AlignCenter, FontSecondary, filename_display);
        widget_add_string_element(
            app->widget, 64, 45, AlignCenter, AlignCenter, FontSecondary, "Press Back to return");
        
        view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixWidgetView);
    } else {
        // Failed to open file
        widget_reset(app->widget);
        widget_add_string_element(
            app->widget, 64, 20, AlignCenter, AlignCenter, FontPrimary, "Error");
        widget_add_string_element(
            app->widget, 64, 35, AlignCenter, AlignCenter, FontSecondary, "Cannot open file");
        view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixWidgetView);
    }
    
    storage_file_close(file);
    storage_file_free(file);
    furi_record_close(RECORD_STORAGE);
}

// Settings callbacks
static void brightness_change_callback(VariableItem* item) {
    App* app = variable_item_get_context(item);
    uint8_t index = variable_item_get_current_value_index(item);
    
    app->brightness = index;
    char brightness_str[4];
    snprintf(brightness_str, sizeof(brightness_str), "%d", index + 1); // Display as 1-16
    variable_item_set_current_value_text(item, brightness_str);
    
    // Update display brightness if connected (pass 0-15 to function)
    if(app->matrix_connected && app->max7219) {
        max7219_set_intensity(app->max7219, index); // index is already 0-15
    }
}

static void scroll_speed_change_callback(VariableItem* item) {
    App* app = variable_item_get_context(item);
    uint8_t index = variable_item_get_current_value_index(item);
    
    app->scroll_speed = index;
    const char* speed_names[] = {"Slow", "Medium", "Fast"};
    variable_item_set_current_value_text(item, speed_names[index]);
    
    // If scrolling is active, restart timer with new interval
    if(app->scroll_active && app->scroll_timer) {
        furi_timer_stop(app->scroll_timer);
        furi_timer_start(app->scroll_timer, get_scroll_timer_interval(app->scroll_speed));
    }
}

static void scroll_direction_change_callback(VariableItem* item) {
    App* app = variable_item_get_context(item);
    uint8_t index = variable_item_get_current_value_index(item);
    
    app->scroll_direction = index;
    const char* direction_names[] = {"Horizontal", "Vertical"};
    variable_item_set_current_value_text(item, direction_names[index]);
    
    // If scrolling is active, reset position for new direction
    if(app->scroll_active) {
        if(app->scroll_direction == 0) { // Horizontal
            app->scroll_position = 8; // Start position for horizontal
        } else { // Vertical
            app->scroll_position = 8; // Start position for vertical
        }
    }
}

void flipmatrix_settings_scene_on_enter(void* context) {
    App* app = context;
    VariableItem* item;
    variable_item_list_reset(app->variable_item_list);
    variable_item_list_set_header(app->variable_item_list, "Settings");
    
    // Brightness setting (0-15)
    item = variable_item_list_add(app->variable_item_list, "Brightness", 16, brightness_change_callback, app);
    variable_item_set_current_value_index(item, app->brightness);
    char brightness_str[4];
    snprintf(brightness_str, sizeof(brightness_str), "%d", app->brightness + 1); // Display as 1-16
    variable_item_set_current_value_text(item, brightness_str);
    
    // Text scrolling speed
    item = variable_item_list_add(app->variable_item_list, "Text scroll speed", 3, scroll_speed_change_callback, app);
    variable_item_set_current_value_index(item, app->scroll_speed);
    const char* speed_names[] = {"Slow", "Medium", "Fast"};
    variable_item_set_current_value_text(item, speed_names[app->scroll_speed]);
    
    // Text scrolling direction
    item = variable_item_list_add(app->variable_item_list, "Scroll direction", 2, scroll_direction_change_callback, app);
    variable_item_set_current_value_index(item, app->scroll_direction);
    const char* direction_names[] = {"Horizontal", "Vertical"};
    variable_item_set_current_value_text(item, direction_names[app->scroll_direction]);
    
    view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixVariableItemListView);
}

bool flipmatrix_settings_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false; // event not handled.
}

void flipmatrix_settings_scene_on_exit(void* context) {
    App* app = context;
    variable_item_list_reset(app->variable_item_list);
}

void flipmatrix_how_to_connect_scene_on_enter(void* context) {
    App* app = context;

    furi_string_reset(app->text_box_store);
    furi_string_cat_str(app->text_box_store, FLIPMATRIX_HOW_TO_CONNECT_TEXT);

    text_box_reset(app->text_box);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_box_store));
    view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixTextBoxView);
}

bool flipmatrix_how_to_connect_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false; // event not handled.
}

void flipmatrix_how_to_connect_scene_on_exit(void* context) {
    App* app = context;
    text_box_reset(app->text_box);
}

void flipmatrix_about_scene_on_enter(void* context) {
    App* app = context;

    furi_string_reset(app->text_box_store);
    furi_string_cat_str(app->text_box_store, FLIPMATRIX_ABOUT_TEXT);

    text_box_reset(app->text_box);
    text_box_set_text(app->text_box, furi_string_get_cstr(app->text_box_store));
    view_dispatcher_switch_to_view(app->view_dispatcher, FlipMatrixTextBoxView);
}

bool flipmatrix_about_scene_on_event(void* context, SceneManagerEvent event) {
    UNUSED(context);
    UNUSED(event);
    return false; // event not handled.
}

void flipmatrix_about_scene_on_exit(void* context) {
    App* app = context;
    text_box_reset(app->text_box);
}

void (*const flipmatrix_scene_on_enter_handlers[])(void*) = {
    flipmatrix_main_menu_scene_on_enter,
    flipmatrix_connect_scene_on_enter,
    flipmatrix_connected_menu_scene_on_enter,
    flipmatrix_text_input_scene_on_enter,
    flipmatrix_text_display_scene_on_enter,
    flipmatrix_flashing_text_input_scene_on_enter,
    flipmatrix_flashing_text_display_scene_on_enter,
    flipmatrix_image_display_scene_on_enter,
    flipmatrix_settings_scene_on_enter,
    flipmatrix_how_to_connect_scene_on_enter,
    flipmatrix_about_scene_on_enter,
};

bool (*const flipmatrix_scene_on_event_handlers[])(void*, SceneManagerEvent) = {
    flipmatrix_main_menu_scene_on_event,
    flipmatrix_connect_scene_on_event,
    flipmatrix_connected_menu_scene_on_event,
    flipmatrix_text_input_scene_on_event,
    flipmatrix_text_display_scene_on_event,
    flipmatrix_flashing_text_input_scene_on_event,
    flipmatrix_flashing_text_display_scene_on_event,
    flipmatrix_image_display_scene_on_event,
    flipmatrix_settings_scene_on_event,
    flipmatrix_how_to_connect_scene_on_event,
    flipmatrix_about_scene_on_event,
};

void (*const flipmatrix_scene_on_exit_handlers[])(void*) = {
    flipmatrix_main_menu_scene_on_exit,
    flipmatrix_connect_scene_on_exit,
    flipmatrix_connected_menu_scene_on_exit,
    flipmatrix_text_input_scene_on_exit,
    flipmatrix_text_display_scene_on_exit,
    flipmatrix_flashing_text_input_scene_on_exit,
    flipmatrix_flashing_text_display_scene_on_exit,
    flipmatrix_image_display_scene_on_exit,
    flipmatrix_settings_scene_on_exit,
    flipmatrix_how_to_connect_scene_on_exit,
    flipmatrix_about_scene_on_exit,
};

static const SceneManagerHandlers flipmatrix_scene_manager_handlers = {
    .on_enter_handlers = flipmatrix_scene_on_enter_handlers,
    .on_event_handlers = flipmatrix_scene_on_event_handlers,
    .on_exit_handlers = flipmatrix_scene_on_exit_handlers,
    .scene_num = FlipMatrixSceneCount,
};

static bool flipmatrix_custom_callback(void* context, uint32_t custom_event) {
    furi_assert(context);
    App* app = context;
    return scene_manager_handle_custom_event(app->scene_manager, custom_event);
}

bool flipmatrix_back_event_callback(void* context) {
    furi_assert(context);
    App* app = context;
    return scene_manager_handle_back_event(app->scene_manager);
}

static App* app_alloc() {
    App* app = malloc(sizeof(App));

    app->scene_manager = scene_manager_alloc(&flipmatrix_scene_manager_handlers, app);
    app->view_dispatcher = view_dispatcher_alloc();
    view_dispatcher_set_event_callback_context(app->view_dispatcher, app);
    view_dispatcher_set_custom_event_callback(app->view_dispatcher, flipmatrix_custom_callback);
    view_dispatcher_set_navigation_event_callback(
        app->view_dispatcher, flipmatrix_back_event_callback);

    app->submenu = submenu_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, FlipMatrixSubmenuView, submenu_get_view(app->submenu));

    app->widget = widget_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, FlipMatrixWidgetView, widget_get_view(app->widget));

    app->text_box = text_box_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, FlipMatrixTextBoxView, text_box_get_view(app->text_box));

    app->text_input = text_input_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, FlipMatrixTextInputView, text_input_get_view(app->text_input));

    app->variable_item_list = variable_item_list_alloc();
    view_dispatcher_add_view(
        app->view_dispatcher, FlipMatrixVariableItemListView, variable_item_list_get_view(app->variable_item_list));

    app->text_box_store = furi_string_alloc();

    // Initialize text input buffer
    memset(app->text_input_buffer, 0, sizeof(app->text_input_buffer));
    strcpy(app->text_input_buffer, "Hello FlipMatrix!");

    // Initialize file path and dialogs
    app->file_path = furi_string_alloc();
    app->dialogs = furi_record_open(RECORD_DIALOGS);

    // Initialize MAX7219 structure
    app->max7219 = malloc(sizeof(MAX7219));
    memset(app->max7219, 0, sizeof(MAX7219));
    app->matrix_connected = false;
    
    // Initialize animation state
    app->scroll_timer = NULL;
    app->scroll_position = 0;
    app->scroll_text = furi_string_alloc();
    app->scroll_active = false;
    
    // Initialize flashing text animation state
    app->flash_timer = NULL;
    app->flash_current_char = 0;
    app->flash_text = furi_string_alloc();
    app->flash_active = false;
    
    // Initialize settings with default values
    app->brightness = 8; // Medium brightness (0-15)
    app->scroll_speed = 1; // Medium speed (0=Slow, 1=Medium, 2=Fast)
    app->scroll_direction = 0; // Horizontal (0=Horizontal, 1=Vertical)

    return app;
}
static void app_free(App* app) {
    furi_assert(app);

    // Stop any running animations
    if(app->scroll_timer) {
        furi_timer_stop(app->scroll_timer);
        furi_timer_free(app->scroll_timer);
    }
    if(app->flash_timer) {
        furi_timer_stop(app->flash_timer);
        furi_timer_free(app->flash_timer);
    }

    // Deinitialize MAX7219 if connected
    if(app->matrix_connected && app->max7219) {
        max7219_deinit(app->max7219);
    }
    if(app->max7219) {
        free(app->max7219);
    }

    view_dispatcher_remove_view(app->view_dispatcher, FlipMatrixSubmenuView);
    view_dispatcher_remove_view(app->view_dispatcher, FlipMatrixWidgetView);
    view_dispatcher_remove_view(app->view_dispatcher, FlipMatrixTextBoxView);
    view_dispatcher_remove_view(app->view_dispatcher, FlipMatrixTextInputView);
    view_dispatcher_remove_view(app->view_dispatcher, FlipMatrixVariableItemListView);
    scene_manager_free(app->scene_manager);
    view_dispatcher_free(app->view_dispatcher);
    submenu_free(app->submenu);
    widget_free(app->widget);
    text_box_free(app->text_box);
    text_input_free(app->text_input);
    variable_item_list_free(app->variable_item_list);
    furi_record_close(RECORD_DIALOGS);
    furi_string_free(app->file_path);
    furi_string_free(app->text_box_store);
    furi_string_free(app->scroll_text);
    furi_string_free(app->flash_text);
    free(app);
}

int32_t flipmatrix_app(void* p) {
    UNUSED(p);
    App* app = app_alloc();

    Gui* gui = furi_record_open(RECORD_GUI);
    view_dispatcher_attach_to_gui(app->view_dispatcher, gui, ViewDispatcherTypeFullscreen);
    scene_manager_next_scene(app->scene_manager, FlipMatrixMainMenuScene);
    view_dispatcher_run(app->view_dispatcher);

    app_free(app);
    return 0;
}
